2. The call to the one argument function produces a compilation error because there is no pre-defined comparison operator (operator>) to compare objects of type Coord. This is a problem for the one argument function because it compares two items of ItemType, which in this case is Coord, whereas the two argument function and a call to this function using type int are allowed because the objects aren't compared or the comparison operator is pre-defined, respectively.

4.b. I could not implement the listAll function that accepted only one parameter because the spec requires the directories that each of the files are in to be printed before the files, which could not be added on to each cout statement unless it is passed in as an argument for each function call. It would be possible to print the individual file names without this extra argument, but requiring the path to be printed as well requires that each call be made aware what the current path is.

5.a. This algorithm is O(N^3) time complexity. The outermost for loop has a limit of N. Inside this loop, another for loop also has a limit of N times, disregarding the single time that i == j. Finally, there is one additional loop inside both of these loops that also has a limit of N times, disregarding the insignifcant times that k == i or k == j. Therefore, as there are a total of 3 loops that are nested that each run a maximum of roughly N times, the time complexity must be O(N^3).

5.b. Despite the new algorithm, this is also O(N^3) time complexity in the worst case. The only significant change between this algorithm and the previous one is the changing of the middle loop limit to 'i' instead of 'N'. However, the outer loop limit says that i<N, which means that in the worst case scenario, the middle loop will still run roughly N times, so the time complexity remains the same.

6.a. Assuming that each sequence has N elements, the time complexity is O(N^2). The first for loop will run with a limit of N. Inside this loop, the only operations that will require accessing ItemType objects are the two .get() functions calls, which would each take roughly N/2 ItemTypes searched (becuase the search starts at either the front or the back to optimize the search). Combining this search time complexity with the for loop complexity yields N*(N/2) = (N^2)/2. However, for big-O, we disregard constant multipliers, therefore the time complexity must be O(N^2). If each sequence had exactly N items, then the bottom loop wouldn't run at all, so shouldn't be considered here (if one were to consider its separate time complexity, it would be N^2, which is the same as the previous loop and therefore the overall complexity would still just be O(N^2)).

6.b. This function has a time complexity of O(N), which is faster than part (a). The first for loop will run roughly N times, and each time it runs it calls a function with a time complexity of constant time complexity. The second for loop follows the same logic, altough it may run less times than the first for loop (but then it doesn't matter for big-O, so we can disregard it).